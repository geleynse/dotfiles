#!/bin/bash
# Server update management script
# Config: ~/.config/server-updates/servers.conf

CONFIG_FILE="$HOME/.config/server-updates/servers.conf"

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

usage() {
    echo "server-update - Manage updates across multiple servers"
    echo ""
    echo "Usage: server-update <command> [server|all]"
    echo ""
    echo "Commands:"
    echo "  list              List all configured servers (invalid types shown in red)"
    echo "  status [name]     Check connectivity (all if no name)"
    echo "  check [name]      Check for updates, offers to apply if any found"
    echo "  apply [name]      Apply updates (all if no name, with confirmation)"
    echo "  apply -y [name]   Apply updates without confirmation"
    echo "  help              Show this help message"
    echo ""
    echo "Examples:"
    echo "  server-update list              # Show all servers"
    echo "  server-update status            # Check all servers are reachable"
    echo "  server-update check proxmox     # Check updates on proxmox only"
    echo "  server-update check             # Check updates on all servers"
    echo "  server-update apply nas         # Update nas server"
    echo "  server-update apply             # Update all servers (with confirmation)"
    echo "  server-update apply -y          # Update all without confirmation"
    echo "  server-update apply -y proxmox  # Update proxmox without confirmation"
    echo ""
    echo "Configuration:"
    echo "  Config file: $CONFIG_FILE"
    echo ""
    echo "  Format: name|type|ssh_command"
    echo ""
    echo "  Server types:"
    echo "    proxmox  - Proxmox host (apt, root access)"
    echo "    debian   - Debian/Ubuntu server (apt with sudo)"
    echo "    ha       - Home Assistant via Proxmox guest exec"
    echo "    gcp      - Google Cloud instance (gcloud compute ssh)"
    echo ""
    echo "  Example config entries:"
    echo "    proxmox|proxmox|ssh -n root@192.168.1.2"
    echo "    nas|debian|ssh -n alan@192.168.1.3"
    echo "    homeassistant|ha|ssh -n root@192.168.1.2 \"qm guest exec 102 --\""
    echo "    gcp-server|gcp|gcloud compute ssh instance-name --zone=us-west1-b --"
    echo ""
    echo "  Note: Use 'ssh -n' to prevent stdin issues when checking multiple servers"
    echo ""
    echo "Features:"
    echo "  - ${SSH_TIMEOUT}s timeout on SSH, ${GCP_TIMEOUT}s for GCP instances"
    echo "  - Warns if config file has insecure permissions"
    echo "  - Shows errors instead of failing silently"
    echo "  - 'check' offers to apply updates when finished"
}

load_servers() {
    if [[ ! -f "$CONFIG_FILE" ]]; then
        echo -e "${RED}Config file not found: $CONFIG_FILE${NC}"
        exit 1
    fi

    # Check config file permissions - warn if group/world writable
    local perms
    perms=$(stat -c '%a' "$CONFIG_FILE" 2>/dev/null)
    if [[ "${perms:1:1}" =~ [2367] ]] || [[ "${perms:2:1}" =~ [2367] ]]; then
        echo -e "${YELLOW}Warning: Config file is writable by group/others. Consider: chmod 600 $CONFIG_FILE${NC}"
    fi
}

# Valid server types
VALID_TYPES="proxmox debian ha gcp"

validate_type() {
    local type=$1
    if [[ ! " $VALID_TYPES " =~ " $type " ]]; then
        echo -e "${RED}Unknown server type '$type'. Valid types: $VALID_TYPES${NC}" >&2
        return 1
    fi
    return 0
}

get_servers() {
    grep -v '^#' "$CONFIG_FILE" | grep -v '^$'
}

# SSH timeout in seconds (GCP instances are slower, especially free-tier)
SSH_TIMEOUT=30
GCP_TIMEOUT=90

run_cmd() {
    local ssh_cmd=$1
    local cmd=$2
    local type=$3
    local result
    local exit_code

    # Add SSH timeout for ssh-based commands
    local timeout_cmd="timeout ${SSH_TIMEOUT}s"

    # Always redirect stdin to prevent commands from consuming loop input
    if [[ "$type" == "gcp" ]]; then
        # GCP uses -- to separate ssh args from command (longer timeout for slow instances)
        result=$(eval "timeout ${GCP_TIMEOUT}s $ssh_cmd \"$cmd\"" </dev/null 2>&1)
        exit_code=$?
    elif [[ "$type" == "ha" ]]; then
        # HA uses qm guest exec which returns JSON
        result=$(eval "$timeout_cmd $ssh_cmd \"$cmd\"" </dev/null 2>&1)
        exit_code=$?
        if [[ $exit_code -eq 0 ]]; then
            result=$(echo "$result" | jq -r '."out-data" // empty' 2>/dev/null)
        fi
    else
        result=$(eval "$timeout_cmd $ssh_cmd \"$cmd\"" </dev/null 2>&1)
        exit_code=$?
    fi

    echo "$result"
    return $exit_code
}

check_connectivity() {
    local name=$1
    local type=$2
    local ssh_cmd=$3
    local timeout_cmd="timeout ${SSH_TIMEOUT}s"

    # Always redirect stdin to prevent commands from consuming loop input
    if [[ "$type" == "gcp" ]]; then
        # GCP needs longer timeout for slow instances
        if eval "timeout ${GCP_TIMEOUT}s $ssh_cmd 'echo test'" </dev/null 2>/dev/null | grep -q test; then
            echo -e "${GREEN}online${NC}"
        else
            echo -e "${RED}offline${NC}"
        fi
    else
        if eval "$timeout_cmd $ssh_cmd 'echo test'" </dev/null &>/dev/null; then
            echo -e "${GREEN}online${NC}"
        else
            echo -e "${RED}offline${NC}"
        fi
    fi
}

check_updates() {
    local name=$1
    local type=$2
    local ssh_cmd=$3
    local has_updates=false
    local result
    local cmd_exit

    echo -e "${BLUE}=== $name ===${NC}"

    # Validate server type
    if ! validate_type "$type"; then
        echo ""
        return 1
    fi

    case $type in
        proxmox)
            result=$(run_cmd "$ssh_cmd" "apt update -qq 2>/dev/null && apt list --upgradable 2>/dev/null" "$type")
            cmd_exit=$?
            if [[ $cmd_exit -ne 0 ]]; then
                echo -e "${RED}Failed to check updates (exit code $cmd_exit)${NC}"
                [[ -n "$result" ]] && echo "$result" | head -3
            elif echo "$result" | grep -q upgradable; then
                has_updates=true
                count=$(echo "$result" | grep -c upgradable)
                echo -e "${YELLOW}$count packages available${NC}"
                echo "$result" | grep upgradable | head -10
                if [[ $count -gt 10 ]]; then
                    echo "  ... and $((count-10)) more"
                fi
            else
                echo -e "${GREEN}Up to date${NC}"
            fi
            ;;
        debian)
            result=$(run_cmd "$ssh_cmd" "sudo apt update -qq 2>/dev/null && apt list --upgradable 2>/dev/null" "$type")
            cmd_exit=$?
            if [[ $cmd_exit -ne 0 ]]; then
                echo -e "${RED}Failed to check updates (exit code $cmd_exit)${NC}"
                [[ -n "$result" ]] && echo "$result" | head -3
            elif echo "$result" | grep -q upgradable; then
                has_updates=true
                count=$(echo "$result" | grep -c upgradable)
                echo -e "${YELLOW}$count packages available${NC}"
                echo "$result" | grep upgradable | head -10
                if [[ $count -gt 10 ]]; then
                    echo "  ... and $((count-10)) more"
                fi
            else
                echo -e "${GREEN}Up to date${NC}"
            fi
            ;;
        ha)
            # Check Core
            core_info=$(run_cmd "$ssh_cmd" "ha core info" "$type")
            cmd_exit=$?
            if [[ $cmd_exit -ne 0 ]] || [[ -z "$core_info" ]]; then
                echo -e "${RED}Failed to get Core info${NC}"
                [[ -n "$core_info" ]] && echo "$core_info" | head -3
            else
                core_version=$(echo "$core_info" | grep "^version:" | awk '{print $2}')
                core_update=$(echo "$core_info" | grep "update_available:" | awk '{print $2}')
                if [[ -z "$core_version" ]]; then
                    echo -e "${RED}Core: Unable to parse version${NC}"
                elif [[ "$core_update" == "true" ]]; then
                    has_updates=true
                    core_latest=$(echo "$core_info" | grep "version_latest:" | awk '{print $2}')
                    echo -e "Core: ${YELLOW}$core_version -> $core_latest available${NC}"
                else
                    echo -e "Core: $core_version"
                fi
            fi
            # Check OS
            os_info=$(run_cmd "$ssh_cmd" "ha os info" "$type")
            cmd_exit=$?
            if [[ $cmd_exit -ne 0 ]] || [[ -z "$os_info" ]]; then
                echo -e "${RED}Failed to get OS info${NC}"
                [[ -n "$os_info" ]] && echo "$os_info" | head -3
            else
                os_version=$(echo "$os_info" | grep "^version:" | awk '{print $2}')
                os_update=$(echo "$os_info" | grep "update_available:" | awk '{print $2}')
                if [[ -z "$os_version" ]]; then
                    echo -e "${RED}OS: Unable to parse version${NC}"
                elif [[ "$os_update" == "true" ]]; then
                    has_updates=true
                    os_latest=$(echo "$os_info" | grep "version_latest:" | awk '{print $2}')
                    echo -e "OS:   ${YELLOW}$os_version -> $os_latest available${NC}"
                else
                    echo -e "OS:   $os_version"
                fi
            fi
            if [[ "$has_updates" != "true" ]] && [[ -n "$core_version" ]] && [[ -n "$os_version" ]]; then
                echo -e "${GREEN}Up to date${NC}"
            fi
            ;;
        gcp)
            result=$(run_cmd "$ssh_cmd" "sudo apt update -qq 2>/dev/null && apt list --upgradable 2>/dev/null" "$type")
            cmd_exit=$?
            if [[ $cmd_exit -ne 0 ]]; then
                echo -e "${RED}Failed to check updates (exit code $cmd_exit)${NC}"
                [[ -n "$result" ]] && echo "$result" | head -3
            elif echo "$result" | grep -q upgradable; then
                has_updates=true
                count=$(echo "$result" | grep -c upgradable)
                echo -e "${YELLOW}$count packages available${NC}"
                echo "$result" | grep upgradable | head -10
                if [[ $count -gt 10 ]]; then
                    echo "  ... and $((count-10)) more"
                fi
            else
                echo -e "${GREEN}Up to date${NC}"
            fi
            ;;
    esac
    echo ""

    # Return 0 if updates available, 1 if up to date
    [[ "$has_updates" == "true" ]]
}

apply_updates() {
    local name=$1
    local type=$2
    local ssh_cmd=$3
    local result
    local cmd_exit
    local had_error=false

    echo -e "${BLUE}=== Updating $name ===${NC}"

    # Validate server type
    if ! validate_type "$type"; then
        echo ""
        return 1
    fi

    case $type in
        proxmox)
            result=$(run_cmd "$ssh_cmd" "apt update -qq && apt upgrade -y" "$type")
            cmd_exit=$?
            if [[ $cmd_exit -ne 0 ]]; then
                had_error=true
                echo -e "${RED}Update failed (exit code $cmd_exit)${NC}"
                [[ -n "$result" ]] && echo "$result" | tail -10
            else
                echo "$result" | tail -5
            fi
            ;;
        debian)
            result=$(run_cmd "$ssh_cmd" "sudo apt update -qq && sudo apt upgrade -y" "$type")
            cmd_exit=$?
            if [[ $cmd_exit -ne 0 ]]; then
                had_error=true
                echo -e "${RED}Update failed (exit code $cmd_exit)${NC}"
                [[ -n "$result" ]] && echo "$result" | tail -10
            else
                echo "$result" | tail -5
            fi
            ;;
        ha)
            echo "Updating Core..."
            result=$(run_cmd "$ssh_cmd" "ha core update" "$type")
            cmd_exit=$?
            if [[ $cmd_exit -ne 0 ]]; then
                had_error=true
                echo -e "${RED}Core update failed${NC}"
                [[ -n "$result" ]] && echo "$result" | head -5
            else
                echo "$result" | head -3
            fi
            echo "Updating OS..."
            result=$(run_cmd "$ssh_cmd" "ha os update" "$type")
            cmd_exit=$?
            if [[ $cmd_exit -ne 0 ]]; then
                had_error=true
                echo -e "${RED}OS update failed${NC}"
                [[ -n "$result" ]] && echo "$result" | head -5
            else
                echo "$result" | head -3
            fi
            ;;
        gcp)
            result=$(run_cmd "$ssh_cmd" "sudo apt update -qq && sudo apt upgrade -y" "$type")
            cmd_exit=$?
            if [[ $cmd_exit -ne 0 ]]; then
                had_error=true
                echo -e "${RED}Update failed (exit code $cmd_exit)${NC}"
                [[ -n "$result" ]] && echo "$result" | tail -10
            else
                echo "$result" | tail -5
            fi
            ;;
    esac

    if [[ "$had_error" == "true" ]]; then
        echo -e "${RED}Completed with errors${NC}"
    else
        echo -e "${GREEN}Done${NC}"
    fi
    echo ""
}

cmd_list() {
    echo -e "${BLUE}Configured Servers:${NC}"
    echo ""
    printf "%-15s %-10s %s\n" "NAME" "TYPE" "CONNECTION"
    printf "%-15s %-10s %s\n" "----" "----" "----------"

    while IFS='|' read -r name type ssh_cmd; do
        if [[ ! " $VALID_TYPES " =~ " $type " ]]; then
            printf "%-15s ${RED}%-10s${NC} %s\n" "$name" "$type" "$ssh_cmd"
        else
            printf "%-15s %-10s %s\n" "$name" "$type" "$ssh_cmd"
        fi
    done < <(get_servers)
}

cmd_status() {
    local target=$1

    echo -e "${BLUE}Server Status:${NC}"
    echo ""
    printf "%-15s %-10s %s\n" "NAME" "TYPE" "STATUS"
    printf "%-15s %-10s %s\n" "----" "----" "------"

    while IFS='|' read -r name type ssh_cmd; do
        if [[ -z "$target" || "$target" == "all" || "$target" == "$name" ]]; then
            status=$(check_connectivity "$name" "$type" "$ssh_cmd")
            printf "%-15s %-10s %b\n" "$name" "$type" "$status"
        fi
    done < <(get_servers)
}

cmd_check() {
    local target=$1
    local servers_with_updates=()

    while IFS='|' read -r name type ssh_cmd; do
        if [[ -z "$target" || "$target" == "all" || "$target" == "$name" ]]; then
            if check_updates "$name" "$type" "$ssh_cmd"; then
                servers_with_updates+=("$name|$type|$ssh_cmd")
            fi
        fi
    done < <(get_servers)

    # Offer to update if any servers have updates
    if [[ ${#servers_with_updates[@]} -gt 0 ]]; then
        echo -e "${YELLOW}Servers with available updates:${NC}"
        for s in "${servers_with_updates[@]}"; do
            echo "  - $(echo "$s" | cut -d'|' -f1)"
        done
        echo ""
        read -p "Apply updates to these servers? [y/N] " confirm
        if [[ "$confirm" == "y" || "$confirm" == "Y" ]]; then
            echo ""
            for s in "${servers_with_updates[@]}"; do
                IFS='|' read -r name type ssh_cmd <<< "$s"
                apply_updates "$name" "$type" "$ssh_cmd"
            done
        fi
    fi
}

cmd_apply() {
    local skip_confirm=false
    local target=""

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case $1 in
            -y|--yes)
                skip_confirm=true
                shift
                ;;
            *)
                target=$1
                shift
                ;;
        esac
    done

    # Default to all if no target specified
    [[ -z "$target" ]] && target="all"

    # Collect servers to update
    local servers=()
    while IFS='|' read -r name type ssh_cmd; do
        if [[ "$target" == "all" || "$target" == "$name" ]]; then
            servers+=("$name|$type|$ssh_cmd")
        fi
    done < <(get_servers)

    if [[ ${#servers[@]} -eq 0 ]]; then
        echo -e "${RED}No matching servers found${NC}"
        exit 1
    fi

    # Confirm unless -y flag
    if [[ "$skip_confirm" != true ]]; then
        echo -e "${YELLOW}Will update the following servers:${NC}"
        for s in "${servers[@]}"; do
            echo "  - $(echo "$s" | cut -d'|' -f1)"
        done
        echo ""
        read -p "Continue? [y/N] " confirm
        if [[ "$confirm" != "y" && "$confirm" != "Y" ]]; then
            echo "Aborted"
            exit 0
        fi
        echo ""
    fi

    for s in "${servers[@]}"; do
        IFS='|' read -r name type ssh_cmd <<< "$s"
        apply_updates "$name" "$type" "$ssh_cmd"
    done
}

# Main
load_servers

case ${1:-} in
    list)
        cmd_list
        ;;
    status)
        cmd_status "${2:-}"
        ;;
    check)
        cmd_check "${2:-all}"
        ;;
    apply)
        shift
        cmd_apply "$@"
        ;;
    help|-h|--help)
        usage
        exit 0
        ;;
    *)
        usage
        exit 1
        ;;
esac
